124.二叉树中的最大路径和

路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中**至多出现一次** 。该路径**至少包含一个节点**，且不一定经过根节点。

路径和是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其最大路径和 。

思路：定义一个dfs函数，返回当前子树能够为父节点提供的最大路径和，这条路径是一条从父节点延伸下去的路径，分三种情况：

- 路径停在当前子树的根节点，当前子树的收益为：`root->val`
- 走入左子树，在当前子树的收益为：`root->val + dfs(root->left)`
- 走入右子树，在当前子树的收益为：`root->val + dfs(root->right)`

因此当前子树能够给父节点提供的最大路径和为`root->val + max(0, max(root->left, root->right))`。同时，最大路径和可能产生在其中一个子树中，因此需要记录每次子树产生的路径和：`ans = max(ans, root->val + left + right)`。

**注：**一条从父节点延伸下来的路径，不能走入左子树又掉头走右子树，**不能两头收益**。要么走左子树要么走右子树。

```C++
class Solution {
    int ans = INT_MIN;
public:
    int dfs(TreeNode* root){
        //结束条件
        if(root == NULL){
            return 0;
        }
        int left = dfs(root->left); //计算左子树的最大路径和
        int right = dfs(root->right); //计算右子树的最大路径和
        // 计算包含当前节点的路径和，并求出最大路径和
        ans = max(ans, root->val + left + right);
        // 计算当前节点作为子树的根节点，能够为父节点提供的最大路径和
        int sum = root->val + max(0, max(left, right));
        return sum < 0 ? 0 : sum; //如果某个子树 dfs 结果为负，走入它，收益不增反减，该子树就没用，需杜绝走入，像对待 null 一样让它返回 0
    }
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return ans;
    }
};
```

