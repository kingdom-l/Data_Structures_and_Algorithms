92.翻转链表II

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表 。

思路1：将`[left, right]`范围内的链表翻转，然后记录翻转后链表的第一节点和最后一个链表，同时记录翻转前链表中第left个节点的前驱节点，和第right个节点的后驱节点。

```C++
class Solution {
public:
    ListNode *next;//存放待翻转链表的第一个节点
    ListNode *succ;//存放翻转后链表的最后一个节点
    //翻转链表，返回翻转后链表的第一个节点
    ListNode* reverseList(ListNode* node, int left, int right){
        ListNode *pre = new ListNode();
        succ = node;
        while(left <= right){
            next = node->next;
            node->next = pre;
            pre = node;
            node = next;
            ++left;
        }
        return pre;//翻转后链表的第一节点
    }
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left == right){
            return head;
        }
        ListNode* val = new ListNode();
        val->next = head;
        int index = 1;
        ListNode* pre = val;
        //来到 left 节点的前一个节点
        while(index < left){
            pre = pre->next;
            index++;
        }
        pre->next = reverseList(pre->next, left, right);
        succ->next = next;
        return val->next;
    }
};
```

**算法步骤**：

- 第1步：用`LeftNode`记录第`left`个节点，`RightNode`记录第`right`个节点，`pre`记录第`left-1`个节点，`succ`记录第`right+1`个节点。
- 第 2 步：先将待反转的区域反转；
- 第 3 步：把 pre 的 next 指针指向反转以后的链表头节点，把反转以后的链表的尾节点的 next 指针指向 succ。

<img src="D:\Data_Structures_and_Algorithms\image\92.翻转链表II.png" width = "500"/>

```C++
class Solution {
public:
    void reverseList(ListNode* head){
        ListNode *pre = new ListNode(-1);
        ListNode *next;
        while(head){
            next = head->next;
            head->next = pre;
            pre = head;
            head = next;
        }
    }
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* val = new ListNode();
        val->next = head;
        ListNode* pre = val;
        //移动到第left - 1个节点
        for(int i = 1; i < left; ++i){
            pre = pre->next;
        }
        //移动到第left个节点
        ListNode *LeftNode = pre->next;
        ListNode *RightNode = pre;
        //移动到第right个节点
        for(int i = 1; i <= right - left + 1; ++i){
            RightNode = RightNode->next;
        }
        ListNode *succ = RightNode->next;
        pre->next = nullptr;
        RightNode->next = nullptr;
        reverseList(LeftNode);
        pre->next = RightNode;
        LeftNode->next = succ;
        return val->next;
    }
};
```

时间复杂度为：O(n)，空间复杂度为：O(1)。

思路2：递归实现链表翻转。

首先从递归翻转整个链表开始，实现代码：

```C++
ListNode* reverseList(ListNode* head){
	if(!head->next){
		return head;
	}
	ListNode *last = reverseList(head->next);//记录翻转后的头节点
    head->next->next = head; //翻转操作
    head->next = nullptr;
    return last;
}
```

进一步深入，翻转前N个节点，实现代码：

<img src="D:\Data_Structures_and_Algorithms\image\92.翻转链表II.jpg" width = "500"/>

```C++
ListNode* succ;
ListNode* reverseN(ListNode* head, int n){
	if(n == 1){
        //记录第n+1个节点
		succ = head->next;
		return head;
	}
	ListNode* last = reverseN(head->next, n - 1);
	head->next->next = head;
	head->next = succ;
	return last;
}
```

翻转链表的一部分，给出一个索引区间`[m, n]`，当`m == 1`时，相当于翻转链表前n个元素；如果`m != 1`时，可以递归移动到第m个节点，同时记第m个节点的相对索引为1，代码如下：

```C++
class Solution {
public:
    ListNode* succ;	// 记录第N + 1个节点
    ListNode* tail; // 记录翻转后链表的尾节点
    ListNode* reverseN(ListNode* head, int N){
        if(N == 1){
            succ = head->next;
            tail = head;            
            return head;
        }
        ListNode *last = reverseN(head->next, N - 1);
        head->next->next = head;
        tail = head;
        head->next = nullptr;
        return last;//翻转后链表的头节点
    }
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left == 1){
            ListNode *last = reverseN(head, right);
            tail->next = succ;
            return last;
        }
        head->next = reverseBetween(head->next, left - 1, right - 1);
        return head;
    }
};
```

