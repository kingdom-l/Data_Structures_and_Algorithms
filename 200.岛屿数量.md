200.岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

**[网格类问题的DFS遍历方法](https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)**

DFS通常是在树或者图结构上进行的，而岛屿问题中的网格结构也可以归结为DFS问题。

首先，二叉树的DFS遍历一般是：

```C++
void traverse(TreeNode* root) {
    // 判断 base case
    if (root == null) {
        return;
    }
    // 访问两个相邻结点：左子结点、右子结点
    traverse(root->left);
    traverse(root->right);
}
```

主要有两个要素：**访问相邻节点**和**判断base case**。

第一个要素：访问相邻节点。由于二叉树的相邻节点只有左子节点和右子节点，DFS遍历只需要递归调用左子树和右子树即可。

第二个要素：判断base case。一般当root指向的子树为空时，就不需要往下遍历；同时，在``root == null``的时候及时返回，防止``root->left``和``root->right``操作出现异常。

那么，类推到网格结构``grid(r,c)``，其相邻的格子分别是``(r-1, c)``、``(r+1, c)``、``(r, c-1)``和``(r, c+1)``。其次，网格DFS中的base case为``0 <= r < grid.size() && 0 <= c < gird[0].size()``。

因此，网格DFS遍历代码：

```C++
bool isArea(vector<vector<int>>& grid, int i, int j){
    return i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size();
}
void dfs(vector<vector<int>>& grid, int i, int j){
	// 判断 base case
    if(!isArea(grid, i, j)){
		return;
	}
    dfs(grid, i + 1, j);
    dfs(grid, i - 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i, j - 1);
}
```

注意，网格遍历可能会遇到遍历过的节点，那如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。比如在遍历所有值为1的陆地时，将每遍历过的陆地格子值改为2。这样当遇到值为2的格子时，就知道是已遍历过的格子。每个格子的取值有三种情况：

- 0——海洋格子
- 1——陆地格子（未遍历）
- 2——陆地格子（已遍历）

```C++
bool isArea(vector<vector<int>>& grid, int i, int j){
    return i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size();
}
void dfs(vector<vector<int>>& grid, int i, int j){
	// 判断 base case
    if(!isArea(grid, i, j)){
		return;
	}
    if(grid[i][j] != 1){
       return;
    }
    grid[i][j] = 2;
    dfs(grid, i + 1, j);
    dfs(grid, i - 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i, j - 1);
}
```

思路：在遇到一个陆地格子时，通过DFS遍历这个岛屿所有陆地，并将已遍历的陆地格子的值置为2，然后岛屿数量加1。

```C++
class Solution {
public:
    bool isAera(vector<vector<char>>& grid, int i, int j){
        return i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size();
    }
    void dfs(vector<vector<char>>& isl, int i, int j){
        if(!isAera(isl, i, j)){
            return;
        }
        if(isl[i][j] != '1'){
            return;
        }
        isl[i][j] = '2';
        dfs(isl, i + 1, j);
        dfs(isl, i - 1, j);
        dfs(isl, i, j + 1);
        dfs(isl, i, j - 1);
    }
    int numIslands(vector<vector<char>>& grid) {
        int num = 0;
        for(int i = 0; i < grid.size(); ++i){
            for(int j = 0; j < grid[0].size(); ++j){
                if(grid[i][j] == '1'){
                    num++;
                    dfs(grid, i, j);//遍历该岛屿
                }
            }
        }
        return num;
    }
};
```

