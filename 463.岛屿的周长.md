463.[岛屿的周长](https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)

给定一个 ``row x col ``的二维网格地图 grid ，其中：$grid[i][j] = 1$ 表示陆地， $grid[i][j] = 0 $表示水域。

网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

思路：

```C++
void dfs(int[][] grid, int r, int c) {
    // 判断 base case
    if (!inArea(grid, r, c)) {
        return;
    }
    // 如果这个格子不是岛屿，直接返回
    if (grid[r][c] != 1) {
        return;
    }
    grid[r][c] = 2; // 将格子标记为「已遍历过」
    
    // 访问上、下、左、右四个相邻结点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}

// 判断坐标 (r, c) 是否在网格中
boolean inArea(int[][] grid, int r, int c) {
    return 0 <= r && r < grid.length 
        	&& 0 <= c && c < grid[0].length;
}
```

对于DFS遍历网格出现直接返回的情况主要有：

- !inArea(grid, r, c)，即坐标``[r][c]``超出网格范围
- ``grid[r][c] != 1 ``即当前格子不是岛屿格子，可以分为两种情况：
  - ``grid[r][c] == 0``，表示当前格子是海洋
  - ``grid[r][c] == 2``，表示当前格子是已遍历的陆地格子

那如何计算岛的周长呢？实际岛屿的周长是计算岛屿全部的边缘，而这些边缘就对应DFS函数返回的位置。如下图，可以将岛屿的边分为两类：

- 与网格边界相邻的边
- 与海洋格子相邻的边

<img src = "D:\Data_Structures_and_Algorithms\image\岛屿周长.jpg" width="600"/>

当我们的 dfs 函数因为「坐标 (r, c) 超出网格范围」返回的时候，实际上就经过了一条黄色的边；而当函数因为「当前格子是海洋格子」返回的时候，实际上就经过了一条蓝色的边。

```C++
class Solution {
public:
    bool isArea(vector<vector<int>>& grid, int i, int j){
        return i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size();
    }
    int dfs(vector<vector<int>>& grid, int i, int j){
        // 函数因为「坐标 (r, c) 超出网格范围」返回，对应一条黄色的边
        if(!isArea(grid, i, j)){
            return 1;
        }
        // 函数因为「当前格子是海洋格子」返回，对应一条蓝色的边
        if(grid[i][j] == 0){
            return 1;
        }
        // 函数因为「当前格子是已遍历的陆地格子」返回，和周长没关系
        if(grid[i][j] == 2){
            return 0;
        }
        grid[i][j] = 2;
        return dfs(grid, i - 1,j) + dfs(grid, i+1, j) + dfs(grid, i, j-1) + dfs(grid, i, j+1);
    }
    int islandPerimeter(vector<vector<int>>& grid) {
        int ans = 0;
        for(int i = 0; i < grid.size(); ++i){
            for(int j = 0; j < grid[0].size(); ++j){
                if(grid[i][j] == 1){
                    return dfs(grid, i, j);
                }
            }
        }
        return 0;
    }
};
```

