143.重排链表

给定一个单链表 L 的头节点 head ，单链表 L 表示为：

`L0 → L1 → … → Ln - 1 → Ln`
请将其重新排列后变为：

`L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …`
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

思路1：使用容器保存单链表L，因为在访问单链表的尾部元素时，需要遍历一遍链表L。之后，利用双指针来实现节点交换

```C++
class Solution {
public:
    void reorderList(ListNode* head) {
        if(!head){
            return;
        }
        ListNode* vir = head;
        vector<ListNode*> nodelist;
        while(vir != nullptr){
            nodelist.push_back(vir);
            vir = vir->next;
        }       
        int i = 0, j = nodelist.size() - 1;
        while(i < j){
            nodelist[i]->next = nodelist[j];
            ++i;
            if(i == j){// 当链表的个数是偶数时
                break;
            }
            nodelist[j]->next = nodelist[i];
            --j;
        }
        nodelist[j]->next = nullptr;
    }
};
```

 思路2：递归

<img src="D:\Data_Structures_and_Algorithms\image\143.重排链表.png" width="450"/>

```C++
class Solution {
public:
    void reorderList(ListNode* head) {
        if(!head || !head->next || !head->next->next){
            return;
        }
        ListNode* vir = head;
        int len = 0;
        while(vir != nullptr){
            ++len;
            vir = vir->next;
        }       
        recurList(head, len);
    }
    ListNode* recurList(ListNode* head, int len){
        if(len == 1){// 表明链表的个数是奇数，head是中间节点
            ListNode* outTail = head->next;
            head->next = nullptr;
            return outTail;
        }
        if(len == 2){ // 表明链表的个数是偶数，head和head->next是中间两节点
            ListNode* outTail = head->next->next;
            head->next->next = nullptr;
            return outTail;
        }
        ListNode* tail = recurList(head->next, len-2); //返回当前head节点对应的尾节点tail，tail将作为head的next节点
        ListNode* subHead = head->next;
        head->next = tail;
        ListNode* outTail = tail->next;
        tail->next = subHead;
        return outTail;
    }
};
```

