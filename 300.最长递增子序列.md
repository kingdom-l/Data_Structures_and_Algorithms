300.最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组` [0,3,1,6,2,2,7]` 的子序列。

思路1：利用回溯法，利用ser_num存放递增子序列，

```C++
class Solution {
    int ans = 0; //存放最大递增子序列的长度
public:
    void backtracking(vector<int>& nums, vector<int>& ser_num, int begin){
        ans = max(ans, (int)ser_num.size());
        if(begin == nums.size() - 1 && ser_num.size() != 0){
            if(nums[begin] > ser_num.back())
                ans = max(ans, (int)ser_num.size() + 1);    
            return; 
        }
        
        for(int i = begin; i < nums.size(); ++i){
            if(ser_num.size() == 0 || nums[i] > ser_num.back()){
                ser_num.push_back(nums[i]);
                backtracking(nums, ser_num, i + 1);
                ser_num.pop_back();    
            }
        }
    }
    int lengthOfLIS(vector<int>& nums) {
        vector<int> path;
        backtracking(nums, path, 0);
        return ans;
    }
};
```

思路2：动态规划

- 状态定义：`dp[i]`的值表示nums以`nums[i]`结尾的最长子序列长度

- 转移方程：设$j \in [0,i)$，在计算`dp[i]`需要遍历区间`[0,i)`

  1. 当`nums[i] > nums[j]`时，`nums[i]`可以接在`nums[j]`之后，则`dp[i] = dp[j] + 1`，要求`[j + 1, i)`中的元素大于`nums[i]`
  2. 当`nums[i] <= nums[j]`时，跳过

  - 由于是遍历j，因此需要计算`dp[j] + 1`的最大值，即每轮执行`dp[i] = max(dp[i], dp[j] + 1)`

- 初始状态：由于每个元素都可以单独成为子序列，因此`dp[i]`每个元素都置为1
- 返回值：返回数组`dp`中最大的元素

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        int ans = 1;
        for(int i = 0; i < nums.size(); ++i){
            for(int j = 0; j < i; ++j){
                if(nums[i] > nums[j]){
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        for(int i = 0; i < dp.size(); ++i){
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

