94.二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

思路1：递归

```C++
class Solution {
public:
    void inorderTranverse(TreeNode* root, vector<int>& res){
        if(root == NULL){
            return;
        }
        inorderTranverse(root->left, res);
        res.push_back(root->val);
        inorderTranverse(root->right, res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        inorderTranverse(root, ans);
        return ans;
    }
};
```

思路2：迭代

```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        if(root == NULL){
            return ans;
        }
        //利用stack来实现迭代遍历二叉树
        stack<TreeNode*> st_treenode;
        TreeNode* cur = root;
        
        while(!st_treenode.empty() || cur){ //当遍历到根节点的右节点时，此时st_treenode为空，但是根节点的右子树还没有遍历，需要添加条件cur != NULL
            if(cur != NULL){
                st_treenode.push(cur);
                cur = cur->left; //左
            }else{
                cur = st_treenode.top(); st_treenode.pop();
                ans.push_back(cur->val); //中
                cur = cur->right; //右
            }
        }
        return ans;
    }
};
```

