46.全排列

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

思路：使用回溯算法，并使用flag容器记录已遍历过的元素，防止下层递归继续操作该元素。

```C++
class Solution {
public:
    void backtracking(vector<vector<int>>& ans, vector<int>& nums, vector<int>& path, vector<bool>& flag, int len){
        if(path.size() == len){// 结束条件
            ans.push_back(path);// 记录结果
            return;
        }
        for(int j = 0; j < len; ++j){// 递归宽度为len
            if(!flag[j]){
                flag[j] = true;
                path.push_back(nums[j]);
                backtracking(ans, nums, path, flag, len);// 递归深度为len
                path.pop_back();// 撤销操作
                flag[j] = false;
            }
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        int len = nums.size();
        vector<vector<int>> ans;
        vector<int> path;
        vector<bool> flag(len, false);
        if(len <= 1){
            ans.push_back(nums);
            return ans;           
        }
        backtracking(ans, nums, path, flag, len);
        return ans;
    }
};
```

