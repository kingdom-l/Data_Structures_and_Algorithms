5.最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

思路1：通过暴力for循环，从字符的首位开始，遍历所有子串，时间复杂度为O($n^3$)，空间复杂度为O(1)。

```C++
class Solution {
public:
    bool isPalindrome(const string& str, int l, int r){
        for(int i = l; i <= r; ++i, --r){
            if(str[i] != str[r]){
                return false;
            }
        }
        return true;
    }
    string longestPalindrome(string s) {
        int length = s.size();
        int max = 1;
        string ans = s.substr(0,1);
        for(int i = 0; i < length; ++i){
            for(int j = i + 1; j < length; ++j){
                if(isPalindrome(s,i,j) && (j - i + 1) > max){
                    max = j - i + 1;
                    ans = s.substr(i,max);                
                }
            }
        }
        return ans;
    }
};
```



思路2：利用动态规划，设dp\[i][j]表示字符串从第i到第j个字母组成的串是否为回文串：

$$
dp[i][j] = \begin{cases}

​						true, \quad如果子串s[i:j]是回文串\\

​						false, \quad其他情况

​			\end{cases}
$$

这里的其他情况包括：

- s[i:j]本身不是回文串
- i>j

在子串长度大于2时，状态转移方程为：$$dp[i][j] = dp[i+1][j-1] \&\& s[i] == s[j]$$，即子串$s[i+1:j-1]$为子串且$s[i] == s[j]$时，子串$s[i:j]$才会是回文串。当子串的长度为2时，只要$s[i] == s[j]$满足，子串$s[i:j]$即为回文串；而子串长度为1时，它本身就是回文串。

```C++
class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.size();
        int maxlen = 1, begin = 0;
        //字符串长度小于2时，返回字符串本身
        if(len < 2){
            return s;
        }
        vector<vector<int>> dp(len, vector<int>(len));
        //初始化子串长度为1为回文子串
        for(int i = 0; i < len; ++i){
            dp[i][i] = true;
        }
        //遍历子串长度
        for(int L = 2; L <= len; ++L){
            //设置子串的起始位置
            for(int i = 0; i < len; ++i){
                //根据子串长度和起始位置确定子串的终止位置
                int j = L + i - 1;
                if(j >= len){
                    break;
                }
                if(s[i] != s[j]){
                    dp[i][j] = false;
                }else{
                    if(j - i + 1 <= 3){//子串长度为3且首尾字符一样，则为回文子串
                        dp[i][j] = true;
                    }else{
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
                if(j - i + 1 > maxlen && dp[i][j]){
                    maxlen = j - i + 1;
                    begin = i;//记录最长回文子串的起始位置
                }
            }
        }
         return s.substr(begin, maxlen);
    }
};
```

