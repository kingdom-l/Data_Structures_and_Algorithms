加油站

思路一：首先此时邮箱的汽油必须大于cost[i]，否则无法达到下一站。如何选择起始站？通过暴力遍历选择起始点，复杂度会达到O(n^2)。解决思路为：寻找`gas[i] > cost[i]`作为起始点。

```C++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int sum = 0;
        for(int i = 0; i < gas.size(); ++i){
            if(gas[i] >= cost[i]){
                sum = 0;
                sum = sum + gas[i] - cost[i];
                int index = (i + 1) % gas.size();
                while(sum > 0 && index != i){
                    sum = sum + gas[index] - cost[index];
                    index = (index + 1) % gas.size();
                }
                if(sum >= 0 && index == i){
                    return i;
                }
            }
        }
        return -1;
    }
};
```

上述思路会出现超出时间限制的例子。

思路二：首先判断总油量是否大于等于总消耗量，如果是，则从下标`i = 0`开始累加`rest[i] = gas[i] - cost[i]`，和记为`curSum`。如果累加到j时，出现`curSum < 0`，说明`[i, j]`区间不能作为起始位置，因此从`j + 1`开始作为起始位置，`curSum`继续从0累加，若还出现`curSum < 0`，则继续更新起始位置。

```C++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int sum = 0;
        int start = 0;
        for(int i = 0; i < gas.size(); ++i){
            curSum += gas[i] - cost[i];
            sum += gas[i] - cost[i];
            if(curSum < 0){//更新起始位置
                curSum = 0;
                start = i + 1;
            }
        }
        if(sum < 0) return -1;//表明总油量小于总消耗量
        return start;
    }
};
```

