827.最大人工岛

给你一个大小为 ``n x n ``二进制矩阵 grid 。最多只能将一格 0 变成 1 。

返回执行此操作后，grid 中最大的岛屿面积是多少？

岛屿由一组上、下、左、右四个方向相连的 1 形成。

思路1：依次将每个海洋格子置为1，然后DFS遍历陆地格子，寻找最大面积的陆地。

```C++
class Solution {
public:
    void dfsto2(vector<vector<int>>& grid, int i, int j){
        if(!isArea(grid, i, j)){
            return;
        }
        if(grid[i][j] != 2){
            return;
        }
        grid[i][j] = 1;
        dfsto2(grid, i - 1, j);
        dfsto2(grid, i + 1, j);
        dfsto2(grid, i, j - 1);
        dfsto2(grid, i, j + 1);
    }
    bool isArea(const vector<vector<int>>& grid, int i, int j){
        return i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size();
    }
    int dfs(vector<vector<int>>& grid, int i, int j){
        if(!isArea(grid, i, j)){
            return 0;
        }
        if(grid[i][j] != 1){
            return 0;
        }
        grid[i][j] = 2;
        return 1 + dfs(grid, i - 1, j) + dfs(grid, i + 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1);
    }
    int largestIsland(vector<vector<int>>& grid) {
        int maxisl = 0;
        for(int i = 0; i < grid.size(); ++i){
            for(int j = 0; j < grid[0].size(); ++j){
                if(grid[i][j] == 0){
                    // 海洋格子置为1
                    grid[i][j] = 1;
                    // DFS遍历陆地格子，保存最大面积的陆地
                    maxisl = max(maxisl, dfs(grid, i, j));
                    // 将DFS遍历过程中，已遍历的陆地格子值改为初始值1
                    dfsto2(grid, i, j);
                    // 恢复为海洋格子
                    grid[i][j] = 0;
                }
            }
        }
        if(maxisl == 0){
            // 当遇到全是陆地格子时
            return dfs(grid, 0, 0);
        }
        return maxisl;
    }
};
```

思路2：

- 首先，深度优先遍历出陆地，获得所有陆地的面积，并将同一块陆地中的格子值置为同一索引值，该索引值是记录陆地面积的索引下标值
- 然后，for遍历每个海洋格子，判断海洋格子的上下左右格子是否为陆地，如果是陆地，并判断是否是同一块陆地，如果不是同一块陆地，进行面积累加。

```C++
class Solution {
public:
    // 面积累加
    int plusArea(vector<vector<int>>& grid, int i, int j, multimap<int, int> land){
        if(!isArea(grid, i, j)){
            return 0;
        }
        if(grid[i][j] != 0){
            return 0;
        }
        set<int> isl_set;
        int area = 0;
        
        if(isArea(grid, i - 1, j) && grid[i-1][j] >= 2){ // 判断是否是一块陆地
            isl_set.insert(grid[i-1][j]); // 如果是不同陆地，会加入到set中
        }
        if(isArea(grid, i + 1, j) && grid[i+1][j] >= 2){
            isl_set.insert(grid[i+1][j]);
        }
        if(isArea(grid, i, j - 1) && grid[i][j-1] >= 2){
            isl_set.insert(grid[i][j-1]);
        }  
        if(isArea(grid, i, j + 1) && grid[i][j+1] >= 2){
            isl_set.insert(grid[i][j+1]);
        }   
        for(auto i : isl_set){
            area += land.find(i)->second;
        } 
        ++area; 
        return area;  
    }
    bool isArea(const vector<vector<int>>& grid, int i, int j){
        return i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size();
    }
    int dfs(vector<vector<int>>& grid, int i, int j, int index){
        if(!isArea(grid, i, j)){
            return 0;
        }
        if(grid[i][j] != 1){
            return 0;
        }
        // 同一块陆地中的格子值置为同一索引值
        grid[i][j] = index;
        return 1 + dfs(grid, i - 1, j, index) + dfs(grid, i + 1, j, index) + dfs(grid, i, j - 1, index) + dfs(grid, i, j + 1, index);
    }
    int largestIsland(vector<vector<int>>& grid) {
        int isl_area = 0, max_area = 0;
        int index = 2;
        multimap<int, int> land_map;
        for(int i = 0; i < grid.size(); ++i){
            for(int j = 0; j < grid[0].size(); ++j){
                if(grid[i][j] == 1){
                    // 统计每块陆地的面积
                    isl_area = dfs(grid, i, j, index); //dfs遍历每块陆地的格子
                    // 保存每一块陆地的面积及索引
                    land_map.insert(pair<int, int>(index, isl_area));
                    ++index;   
                }
            }
        }
        for(int i = 0; i < grid.size(); ++i){
            for(int j = 0; j < grid[0].size(); ++j){
                if(grid[i][j] == 0){
                    max_area = max(max_area, plusArea(grid, i, j, land_map));
                }
            }
        }
        if(max_area == 0){
            max_area = isl_area;
        }
        return max_area;
    }
};
```

