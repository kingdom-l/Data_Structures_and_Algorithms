42.接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 思路1：按照列来计算，在求解每一列的雨水时，只需要寻找左边最高的墙和右边最高的墙。至于装多少水，根据木桶效应，从左边最高的墙和右边最高的墙中选择较矮的一个，然后较矮的墙的高度减去当前的高度，即为雨水的含量。时间复杂度为O($n^2$)

- 左右两边最高的墙中较矮的墙的高度大于当前列的墙的高度

<img src='D:\Data_Structures_and_Algorithms\image\42.接雨水1.png' width="500"/>

- 左右两边最高的墙中较矮的墙的高度小于当前列的墙的高度（当前列没有雨水）

<img src='D:\Data_Structures_and_Algorithms\image\42.接雨水2.png' width="500"/>

- 左右两边最高的墙中较矮的墙的高度等于当前列的墙的高度（当前列没有雨水）

<img src='D:\Data_Structures_and_Algorithms\image\42.接雨水3.png' width="500"/>

```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        //最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2
        for(int i = 1; i < height.size() - 1; ++i){
            int lheight = 0, rheight = 0;
            for(int j = 0; j < i; ++j){
                if(height[j] > height[i]){
                    //记录左边最高的柱子
                    lheight = max(lheight, height[j]);
                }
            }
            for(int k = i + 1; k < height.size(); ++k){
                if(height[k] > height[i]){
                    rheight = max(rheight, height[k]);
                }
            }
            //只有较小的一段大于当前列的高度才会有水，其他情况不会有水
            if(lheight > height[i] && rheight > height[i]){
                ans = ans + min(lheight, rheight) - height[i];
            }
        }
        return ans;
    }
};
```

思路2：动态规划，时间复杂度为O(n)，空间复杂度为O(n)

- 确定dp数组以及定义：对于每一列，都需要求解它左边最高的墙和右边最高的墙，都需要重新遍历一遍所有高度。因此，使用两个数组：`max_left[i]`表示第i列左边墙最高的高度，`max_right[i]`表示第i列右边墙最高的高度，此处不包括第i列。
- 确定递推公式：`max_left[i] = max(max_left[i - 1], heigth[i - 1])`，`max_right[i] = max(max_right[i + 1], height[i + 1])`
- 初始化：`max_left[0] = 0`，`max_right[height.size() - 1] = 0`
- 遍历顺序：`max_left`是从`i = 0`开始往后遍历，而`max_right`是从`height.size() - 1`开始往前遍历

```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0, len = height.size();
        vector<int> max_left(len, 0), max_right(len, 0);
        for(int i = 1; i < len; ++i){
            max_left[i] = max(max_left[i - 1], height[i - 1]);
            max_right[len - 1 - i] = max(max_right[len - i], height[len - i]);
        }
        for(int i = 1; i < height.size() - 1; ++i){
            if(max_left[i] > height[i] && max_right[i] > height[i]){
                ans = ans + min(max_left[i], max_right[i]) - height[i];
            }
        }
        return ans;
    }
};
```

