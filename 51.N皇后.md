51.N皇后

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个不同的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

思路：

回溯算法（暴力搜索）可以解决的问题：<span style = 'color : red'>组合问题、切割问题、子集问题、排列问题、棋盘问题。</span>

```C++
class Solution {
public:
    bool isValide(vector<string>& path, int row, int col, int n){
        // 检查列
        for(int i = 0; i < row; ++i){
            if(path[i][col] == 'Q'){
                return false;
            }
        }
        // 检查 45度角是否有皇后
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j){
            if(path[i][j] == 'Q'){
                return false;
            }
        }
        // 检查 135度角是否有皇后
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j){
            if(path[i][j] == 'Q'){
                return false;
            }
        }
        return true;
    }
    void backtracking(vector<vector<string>>& res, vector<string>& path, int row, int n){// 考虑在第row行摆放'Q'
        if(row == n){
            res.push_back(path);//存放结果
            return;
        }
        for(int j = 0; j < n; ++j){// 每一层里for循环的j控制棋盘的列，尝试摆放同一行的下一个位置
            if(isValide(path, row, j, n)){
                path[row][j] = 'Q';//在第row行插入'Q'
                backtracking(res, path, row + 1, n);// 递归到下一行
                path[row][j] = '.';
            }      
        }
        // 到行尾还不能放置皇后，就退回到上一行
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;
        vector<string> path(n, string(n,'.'));
        backtracking(ans, path, 0, n);
        return ans;
    }
};
```

