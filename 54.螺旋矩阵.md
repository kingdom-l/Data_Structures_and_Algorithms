54.螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

思路：

模拟顺时针画矩阵的过程：

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

<img src="D:\Data_Structures_and_Algorithms\image\54.螺旋矩阵.png" width = "500"/>

利用`loop`记录需要循环的次数。

```C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int r = matrix.size(), c = matrix[0].size();
        int loop = min(r,c)/2; // 记录需要循环的次数
        int startx = 0, starty = 0, offset = 0;
        vector<int> ans;
        while(loop--){
            for(int i = offset; i < c - 1 - offset; ++i){// 每次循环的起始点为[0,0],[1,1],[2,2]...
                ans.push_back(matrix[startx][i]);
            }
            starty = c - 1 - offset;
            for(int j = startx; j < r - 1 - offset; ++j){// 填充右列从上到下
                ans.push_back(matrix[j][starty]);
            }
            startx = r - 1 - offset;
            for(int i = starty ; i > 0 + offset; --i){// 填充下行从右到左
                ans.push_back(matrix[startx][i]);
            }
            starty = 0 + offset;
            for(int j = startx ; j > 0 + offset; --j){// 填充左列从下到上
                ans.push_back(matrix[j][starty]);
            }
            ++offset;
            startx = offset;
        }
        if(min(r,c) % 2){//当行数或列数出现奇数时，需要遍历剩余的一行或一列
            if(r > c){
                int mid = c / 2;
                for(int i = mid; i < r - mid; ++i){
                    ans.push_back(matrix[i][mid]);
                }
            }else{
                int mid = r / 2;
                for(int j = mid; j < c - mid; ++j){
                    ans.push_back(matrix[mid][j]);
                }
            }
        }
        return ans;
    }
};
```

