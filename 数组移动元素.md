对于暴力解法的时间复杂度为什么是O(n^2)？

主要是有for循环嵌套。

例题：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

双指针

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0;
        int right = nums.size() - 1;
        for(; left <= right; left++){
            if(nums[left] == val){
                while(right >= 0 && nums[right] == val){
                    right--;
                }
                if (left < right){
                    nums[left] = nums[right];
                    right--;
                } 
            }
            else
                continue;
        }
        //if(nums.size() == 0)
        //    return left;
        //else
            return right + 1;
    }
};
```

双指针可以从中间往两边去遍历，但是需要考虑当某一指针移至边界时，将另一指针还未遍历完的情况；也可以使用两个指针分别指向数组的头部和尾部，这种无需处理某一指针移动至边界的情况；也可以同时从数组的一边出发。

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int n = nums.size();
        int left = 0;
        for (int right = 0; right < n; right++) {
            if (nums[right] != val) {
                nums[left] = nums[right];
                left++;
            }
        }
        return left;
    }
};
```

整个过程保持不变的性质是：区间[0,left) 中的元素都不等于val。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次。

方法二：双指针优化

两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。

**算法**

如果左指针left指向的元素等于val，此时将right指向的元素复制到left指向的位置，然后right左移一位，如果复制的元素恰好等于val，可以继续左移right并将指向的元素赋值给left指向的位置，直到left指向的元素不再是val。当左指针和右指针重合的时候，左右指针遍历完数组中所有的元素。这样的方法在最坏的情况下只遍历一次。

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
    	int right = nums.size() - 1;	//int right = nums.size();
    	int left = 0;
    	while(left <= right){			//while(left < right)
			if(nums[left] == val){
				nums[left] = nums[right];	//nums[left] = nums[right - 1];
				right--;
			}else{
				left++;
			}
		}
    	return left;
    }
}；
```

