142.环形链表II

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改链表。

思路：利用快慢指针，如果慢指针追上快指针，说明链表有环。时间复杂度为

```C++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* val = new ListNode(-1);
        val->next = head;
        ListNode *fptr = val, *sptr = val; 
        while(fptr && sptr){
            if(!fptr->next){
                return NULL;
            }
            sptr = sptr->next;
            fptr = fptr->next->next;
            if(fptr == sptr){// 链表有环
                ListNode* tem = val;
                while(tem != fptr){// 寻找环的入口
                    tem = tem->next;
                    fptr = fptr->next;
                }
                return fptr;
            }
        }
        return NULL;       
    }
};
```

```C++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(head == NULL || head->next == NULL){
            return NULL;
        }
       ListNode* slow = head->next;
       ListNode* fast = head->next->next;
       //判断是否环
       while(fast != slow){
           if(fast != nullptr && fast->next != nullptr){
               slow = slow->next;
               fast = fast->next->next;
               continue;
           }
           return NULL;
       } 
       slow = head;
       //确定环入口
       while(fast != slow){
           fast = fast->next;
           slow = slow->next;
       }
       return fast;
    }
};
```

